DELIMITER $$/*!50003 CREATE DEFINER=`root`@`localhost` PROCEDURE `_get_json_token`(    IN      p_text      TEXT CHARSET utf8,   INOUT   p_from      INT UNSIGNED,   INOUT   p_level     INT,   OUT     p_token     TEXT CHARSET utf8,   IN      allow_script_tokens INT,   INOUT   p_state     ENUM(                            'alpha'                        ,   'alphanum'                        ,   'colon'                        ,   'comma'                                                ,   'decimal'                        ,   'error'                        ,   'integer'                        ,   'number'                        ,   'minus'                        ,   'object_begin'                        ,   'object_end'                        ,   'array_begin'                        ,   'array_end'                        ,   'start'                        ,   'string'                        ,   'whitespace'                        )               )    NO SQL    DETERMINISTIC    SQL SECURITY INVOKER    COMMENT 'Reads a token according to lexical rules for JSON'BEGIN        DECLARE v_length INT UNSIGNED DEFAULT CHARACTER_LENGTH(p_text);    DECLARE v_char, v_lookahead, v_quote_char    VARCHAR(1) CHARSET utf8;    DECLARE v_from INT UNSIGNED;    DECLARE negative_number BOOL DEFAULT FALSE;    IF p_from IS NULL THEN        SET p_from = 1;    END IF;    IF p_level IS NULL THEN        SET p_level = 0;    END IF;    IF p_state = 'object_end' THEN        SET p_level = p_level - 1;    END IF;    IF p_state = 'array_end' AND allow_script_tokens THEN        SET p_level = p_level - 1;    END IF;    SET v_from = p_from;        SET p_token = ''    ,   p_state = 'start';    my_loop: WHILE v_from <= v_length DO        SET v_char = SUBSTR(p_text, v_from, 1)        ,   v_lookahead = SUBSTR(p_text, v_from+1, 1)        ;        IF v_char = '-' THEN            SET negative_number := TRUE, v_from = v_from + 1;            ITERATE my_loop;        END IF;        state_case: BEGIN CASE p_state            WHEN 'error' THEN                 SET p_from = v_length;                LEAVE state_case;                        WHEN 'start' THEN                CASE                    WHEN v_char = '-' THEN                        SET p_state = 'minus', v_from = v_from + 1;                    WHEN v_char BETWEEN '0' AND '9' THEN                         SET p_state = 'integer';                    WHEN v_char BETWEEN 'A' AND 'Z'                     OR   v_char BETWEEN 'a' AND 'z'                     OR   v_char = '_' THEN                        SET p_state = 'alpha';                                            WHEN v_char = ' ' THEN                         SET p_state = 'whitespace'                        ,   v_from = v_length - CHARACTER_LENGTH(LTRIM(SUBSTRING(p_text, v_from)))                        ;                        LEAVE state_case;                    WHEN v_char IN ('\t', '\n', '\r') THEN                         SET p_state = 'whitespace';                    WHEN v_char = '"' THEN                        SET p_state = 'string', v_quote_char = v_char;                    WHEN v_char = '.' THEN                        IF SUBSTR(p_text, v_from + 1, 1) BETWEEN '0' AND '9' THEN                            SET p_state = 'decimal', v_from = v_from + 1;                        ELSE                            SET p_state = 'error';                            LEAVE my_loop;                        END IF;                    WHEN v_char = ',' THEN                        SET p_state = 'comma', v_from = v_from + 1;                        LEAVE my_loop;                    WHEN v_char = ':' THEN                         SET p_state = 'colon', v_from = v_from + 1;                        LEAVE my_loop;                    WHEN v_char = '{' THEN                         SET p_state = 'object_begin', v_from = v_from + 1, p_level = p_level + 1;                        LEAVE my_loop;                    WHEN v_char = '}' THEN                        SET p_state = 'object_end', v_from = v_from + 1;                        LEAVE my_loop;                    WHEN v_char = '[' THEN                         SET p_state = 'array_begin', v_from = v_from + 1, p_level = p_level + 1;                        LEAVE my_loop;                    WHEN v_char = ']' THEN                         SET p_state = 'array_end', v_from = v_from + 1;                        LEAVE my_loop;                    ELSE                         SET p_state = 'error';                END CASE;            WHEN 'alpha' THEN                 CASE                    WHEN v_char BETWEEN 'A' AND 'Z'                     OR   v_char BETWEEN 'a' AND 'z'                     OR   v_char = '_' THEN                        LEAVE state_case;                    WHEN v_char BETWEEN '0' AND '9' THEN                         SET p_state = 'alphanum';                    ELSE                        LEAVE my_loop;                END CASE;            WHEN 'alphanum' THEN                 CASE                    WHEN v_char BETWEEN 'A' AND 'Z'                     OR   v_char BETWEEN 'a' AND 'z'                     OR   v_char = '_'                    OR   v_char BETWEEN '0' AND '9' THEN                         LEAVE state_case;                    ELSE                        LEAVE my_loop;                END CASE;            WHEN 'integer' THEN                CASE                     WHEN v_char BETWEEN '0' AND '9' THEN                         LEAVE state_case;                    WHEN v_char = '.' THEN                         SET p_state = 'decimal';                    ELSE                        LEAVE my_loop;                                        END CASE;            WHEN 'decimal' THEN                CASE                     WHEN v_char BETWEEN '0' AND '9' THEN                         LEAVE state_case;                    ELSE                        LEAVE my_loop;                END CASE;            WHEN 'whitespace' THEN                IF v_char NOT IN ('\t', '\n', '\r') THEN                    LEAVE my_loop;                                        END IF;            WHEN 'string' THEN                SET v_from = LOCATE(v_quote_char, p_text, v_from);                IF v_from THEN                    IF SUBSTR(p_text, v_from + 1, 1) = v_quote_char THEN                        SET v_from = v_from + 1;                    ELSEIF SUBSTR(p_text, v_from - 1, 1) != '\\' THEN                        SET v_from = v_from + 1;                        LEAVE my_loop;                    END IF;                ELSE                    SET p_state = 'error';                    LEAVE my_loop;                END IF;            ELSE                LEAVE my_loop;                    END CASE; END state_case;        SET v_from = v_from + 1;    END WHILE my_loop;    SET p_token = SUBSTR(p_text, p_from, v_from - p_from) COLLATE utf8_general_ci;    SET p_from = v_from;    IF p_state IN ('decimal', 'integer') THEN      SET p_state := 'number';    END IF;    IF p_state = 'alphanum' THEN      SET p_state := 'alpha';    END IF;    IF negative_number AND (p_state != 'number') THEN    	SET p_token := NULL;    END IF;END */$$DELIMITER ;